<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java实现生产者消费者模型 | 站在海边看远方</title>
<meta name=keywords content="java,juc"><meta name=description content="案例
Java并发的时候，看到了一个关于生产者消费者的案例
一个producer类和一个consumer类，实现了Runnable接口，作为线程执行的任务
一个Queue类，实现了queue的put()和take操作，模拟了生产和消费2个动作
实现方式使用了ReentrantLock+Condition"><meta name=author content="since"><link rel=canonical href=https://blog.thend03.com/posts/tech/java-producer-consumer-model/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.thend03.com/img/logo.jpg><link rel=icon type=image/png sizes=16x16 href=https://blog.thend03.com/img/logo.jpg><link rel=icon type=image/png sizes=32x32 href=https://blog.thend03.com/img/logo.jpg><link rel=apple-touch-icon href=https://blog.thend03.com/img/logo.jpg><link rel=mask-icon href=https://blog.thend03.com/img/logo.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.thend03.com/posts/tech/java-producer-consumer-model/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="Java实现生产者消费者模型"><meta property="og:description" content="案例
Java并发的时候，看到了一个关于生产者消费者的案例
一个producer类和一个consumer类，实现了Runnable接口，作为线程执行的任务
一个Queue类，实现了queue的put()和take操作，模拟了生产和消费2个动作
实现方式使用了ReentrantLock+Condition"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thend03.com/posts/tech/java-producer-consumer-model/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-27T15:52:52+08:00"><meta property="article:modified_time" content="2025-02-27T15:52:52+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java实现生产者消费者模型"><meta name=twitter:description content="案例
Java并发的时候，看到了一个关于生产者消费者的案例
一个producer类和一个consumer类，实现了Runnable接口，作为线程执行的任务
一个Queue类，实现了queue的put()和take操作，模拟了生产和消费2个动作
实现方式使用了ReentrantLock+Condition"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://blog.thend03.com/posts/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻 技术","item":"https://blog.thend03.com/posts/tech/"},{"@type":"ListItem","position":3,"name":"Java实现生产者消费者模型","item":"https://blog.thend03.com/posts/tech/java-producer-consumer-model/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java实现生产者消费者模型","name":"Java实现生产者消费者模型","description":"案例 Java并发的时候，看到了一个关于生产者消费者的案例\n一个producer类和一个consumer类，实现了Runnable接口，作为线程执行的任务\n一个Queue类，实现了queue的put()和take操作，模拟了生产和消费2个动作\n实现方式使用了ReentrantLock+Condition\n","keywords":["java","juc"],"articleBody":"案例 Java并发的时候，看到了一个关于生产者消费者的案例\n一个producer类和一个consumer类，实现了Runnable接口，作为线程执行的任务\n一个Queue类，实现了queue的put()和take操作，模拟了生产和消费2个动作\n实现方式使用了ReentrantLock+Condition\n这个示例代码的话，是可以实现多线程之间并发生产和消费的，多个线程共同操作一个Queue对象，可以实现队列满时生产等待，队列空时消费等待，且无并发问题。\n我当时产生的疑问是为什么使用了ReentrantLock，还要使用Condition\n这个问题下一个章节再说，先贴下示例代码\nProducer\npublic class Producer implements Runnable { Queue queue = null; public Producer(Queue queue) { this.queue = queue; } @Override public void run() { String threadName = Thread.currentThread().getName(); try { // 隔10秒轮询生产一次 while (true) { System.out.println(\"Producer\"); TimeUnit.SECONDS.sleep(10); queue.put(new Random().nextInt(100),threadName); } } catch (Exception e) { e.printStackTrace(); } } } Consumer\npublic class Consumer implements Runnable { Queue queue = null; public Consumer(Queue queue) { this.queue = queue; } @Override public void run() { String threadName = Thread.currentThread().getName(); try { // 隔3秒轮询消费一次 while (true) { System.out.println(\"Customer\"); TimeUnit.SECONDS.sleep(3); System.out.println(\"取到的值-\" + queue.take()); } } catch (Exception e) { e.printStackTrace(); } } } Queue\npublic class Queue { private int[] arr = new int[5]; private int size = 0; private int putIndex = 0; // 生产位置 private int takeIndex = 0; // 消费位置 private ReentrantLock lock = new ReentrantLock(); private Condition pCondition = lock.newCondition(); private Condition cCondition = lock.newCondition(); public boolean isEmpty() { return size==0; } public boolean isFull() { return size==5; } public void put(Integer value, String name) throws InterruptedException { log(name + \" ▶▶▶ 尝试获取锁...\"); lock.lock(); try { log(name + \" ✅ 成功获取锁 | 当前锁状态: \" + lock); while (isFull()) { log(name + \" ⏸️ 队列已满，进入等待 (pCondition.await())...\"); pCondition.await(); // 自动释放锁！ log(name + \" 🔄 被唤醒，重新获取锁 | 当前锁状态: \" + lock); } arr[putIndex] = value; putIndex = (putIndex + 1) % arr.length; size++; // 生产逻辑... log(name + \" 🔔 生产完成，唤醒消费者 (cCondition.signalAll())\"); cCondition.signalAll(); } finally { lock.unlock(); log(name + \" ⏹️ 释放锁 | 当前锁状态: \" + lock); } } public int take() throws InterruptedException { String threadName = Thread.currentThread().getName(); log(threadName + \" ▶▶▶ 尝试获取锁...\"); lock.lock(); try { log(threadName + \" ✅ 成功获取锁 | 当前锁状态: \" + lock); while (isEmpty()) { log(threadName + \" ⏸️ 队列为空，进入等待 (cCondition.await())...\"); cCondition.await(); // 自动释放锁！ log(threadName + \" 🔄 被唤醒，重新获取锁 | 当前锁状态: \" + lock); } int value = arr[takeIndex]; arr[takeIndex] = 0; // 可选：清理数据以便调试 takeIndex = (takeIndex + 1) % arr.length; size--; log(threadName + \" 🔔 消费完成，唤醒生产者 (pCondition.signalAll())\"); pCondition.signalAll(); return value; } finally { lock.unlock(); log(threadName + \" ⏹️ 释放锁 | 当前锁状态: \" + lock); } } private void log(String message) { System.out.printf(\"[%s] %s%n\", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME), message); } } 分析 代码测试 首先写了个测试类，测试了一下生产消费逻辑, 2个生产者，2个消费者，共4个线程，操作同一个queue，实现生产消费逻辑\npublic static void main(String[] args) { // 两个生产者，两个消费者 Queue queue = new Queue(); Thread producer1 = new Thread(new Producer(queue)); producer1.setName(\"Producer1\"); producer1.start(); Thread producer2 = new Thread(new Producer(queue)); producer2.setName(\"Producer2\"); producer2.start(); Thread Consumer1 = new Thread(new Consumer(queue)); Consumer1.setName(\"Consumer1\"); Consumer1.start(); Thread Consumer2 = new Thread(new Consumer(queue)); Consumer2.setName(\"Consumer2\"); Consumer2.start(); } 控制台部分输出内容如下\n输出内容展示了尝试获取锁—-\u003e获取锁成功—-\u003e等待—-\u003e释放锁—-\u003e被唤醒—-\u003e重新获取锁—-\u003e生产/消费完成并唤醒等待的线程—-\u003e释放锁的这么一个过程\n[16:14:07.504] Consumer1 ▶▶▶ 尝试获取锁... [16:14:07.504] Consumer2 ▶▶▶ 尝试获取锁... [16:14:07.516] Consumer1 ✅ 成功获取锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Locked by thread Consumer1] [16:14:07.516] Consumer1 ⏸️ 队列为空，进入等待 (cCondition.await())... [16:14:07.516] Consumer2 ✅ 成功获取锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Locked by thread Consumer2] [16:14:07.516] Consumer2 ⏸️ 队列为空，进入等待 (cCondition.await())... [16:14:14.5] Producer2 ▶▶▶ 尝试获取锁... [16:14:14.501] Producer2 ✅ 成功获取锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Locked by thread Producer2] [16:14:14.502] Producer2 🔔 生产完成，唤醒消费者 (cCondition.signalAll()) [16:14:14.5] Producer1 ▶▶▶ 尝试获取锁... [16:14:14.502] Consumer1 🔄 被唤醒，重新获取锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Locked by thread Consumer1] [16:14:14.502] Producer2 ⏹️ 释放锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Unlocked] Producer [16:14:14.503] Consumer1 🔔 消费完成，唤醒生产者 (pCondition.signalAll()) [16:14:14.504] Consumer2 🔄 被唤醒，重新获取锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Locked by thread Consumer2] [16:14:14.504] Consumer1 ⏹️ 释放锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Unlocked] [16:14:14.504] Consumer2 ⏸️ 队列为空，进入等待 (cCondition.await())... 取到的值-68 Customer [16:14:14.504] Producer1 ✅ 成功获取锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Locked by thread Producer1] [16:14:14.505] Producer1 🔔 生产完成，唤醒消费者 (cCondition.signalAll()) [16:14:14.505] Producer1 ⏹️ 释放锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Unlocked] Producer [16:14:14.505] Consumer2 🔄 被唤醒，重新获取锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Locked by thread Consumer2] [16:14:14.506] Consumer2 🔔 消费完成，唤醒生产者 (pCondition.signalAll()) [16:14:14.506] Consumer2 ⏹️ 释放锁 | 当前锁状态: java.util.concurrent.locks.ReentrantLock@363b2ca2[Unlocked] 取到的值-83 疑问 一开始由于对这快内容不是很了解，我产生了2个疑问，\n线程只要获取锁之后，其他线程都得等待获取锁，多个线程只用竞争一把锁，为什么要使用condition呢。 线程在获取锁之后，只能等待锁执行完释放才能重新竞争到锁，加了condition等待唤醒有什么用呢 带着这2个疑问，我去问了deepseek和grok以及chatgpt，靠ai给思路，然后去看了代码，确认了使用condition的合理性和必要性\n问题1 先看看grok怎么回答问题1的\n只使用lock\n单独使用 Lock 通常会通过忙等待（busy-waiting）或简单的条件检查来模拟生产者-消费者的同步\nLock lock = new ReentrantLock(); Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); int capacity = 10; public void put(int item) { lock.lock(); try { while (queue.size() \u003e= capacity) { lock.unlock(); // 临时释放锁 Thread.yield(); // 让出 CPU lock.lock(); // 重新获取锁 } queue.add(item); } finally { lock.unlock(); } } public void take() { lock.lock(); try { while (queue.isEmpty()) { lock.unlock(); Thread.yield(); lock.lock(); } queue.poll(); } finally { lock.unlock(); } } 只使用lock，会频繁判断条件，写出如上的加锁/释放锁的代码，以及要让出cpu，不够优雅\n结合lock+condition\n使用 Lock 和 Condition，可以通过条件变量精确控制线程的等待和唤醒\nLock lock = new ReentrantLock(); Condition pCondition = lock.newCondition(); Condition cCondition = lock.newCondition(); Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); int capacity = 10; public void produce(int item) { lock.lock(); try { while (queue.size() \u003e= capacity) { pCondition.await(); // 等待“非满”条件 } queue.add(item); cCondition.signal(); // 唤醒等待“非空”的消费者 } finally { lock.unlock(); } } public void consume() { lock.lock(); try { while (queue.isEmpty()) { cCondition.await(); // 等待“非空”条件 } queue.poll(); pCondition.signal(); // 唤醒等待“非满”的生产者 } finally { lock.unlock(); } } lock+condition，可以精准控制线程的等待和唤醒\n使用了2个condition，queue满了pCondition就等待，暂停生产，queue空了cCondition就等待，暂停消费\n生产之后， 释放信号，唤醒cCondition去消费，消费之后，唤醒pCondition去生产\n2种实现方式优缺点比较\n特性 只使用 Lock 使用 Lock + Condition 线程通知 无法精确通知，依赖轮询 精确通知，通过 signal() 唤醒 效率 忙等待或频繁锁切换，效率低 线程挂起，无忙等待，效率高 锁竞争 高，可能反复释放和获取锁 低，唤醒后队列式获取锁 代码复杂度 高，手动实现等待逻辑 低，API 简洁且功能强大 条件区分 无法区分不同条件 支持多个 Condition 对象 中断处理 手动检查和处理 内置支持，抛出异常 通过以上的优缺点比较，可以看到单独使用lock，有以下缺点\n缺乏精确的线程通知机制 效率低下，忙等待或锁切换开销大。 更高的锁竞争和延迟。 代码复杂且不够优雅。 无法区分不同等待条件。 中断处理困难。 在实际的生产场景种\n假设一个高并发生产者-消费者系统：\n只使用 Lock 缓冲区满时，生产者线程不断轮询，浪费 CPU。 消费者被唤醒后可能发现缓冲区仍空（其他消费者抢先消费），需要再次等待。 系统吞吐量低，延迟高。 使用 Lock + Condition 生产者等待 pCondition，消费者等待 cCondition，互不干扰。 生产者放入数据后只唤醒消费者，消费者移除数据后只唤醒生产者。 系统高效运行，资源利用率高。 问题2 再看看问题2的回答\n获取condition使用的是lock的api，返回的是定义在aqs中的conditionobject\nprivate ReentrantLock lock = new ReentrantLock(); private Condition pCondition = lock.newCondition(); private Condition cCondition = lock.newCondition(); 调用pCondition.await(); 实际是调用了java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#await()\n我将aqs的方法代码，喂给了grok，让grok帮我分析方法实现的细节\n/** * 实现可中断的条件等待。 * * 如果当前线程被中断，则抛出 InterruptedException 异常。 * 保存由 {@link #getState} 返回的锁状态。 * 使用保存的状态作为参数调用 {@link #release} 方法， * 如果失败则抛出 IllegalMonitorStateException 异常。 * 阻塞，直到被唤醒或被中断。 * 通过调用 {@link #acquire} 的特定版本，并传入保存的状态作为参数来重新获取锁。 * 如果在第 4 步阻塞时被中断，则抛出 InterruptedException 异常。 * */ /** * Implements interruptible condition wait. * * If current thread is interrupted, throw InterruptedException. * Save lock state returned by {@link #getState}. * Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * Block until signalled or interrupted. * Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument. * If interrupted while blocked in step 4, throw InterruptedException. * */ public final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); //释放锁 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) { LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } grok帮我总结出了如下重点\n锁的释放： 在 fullyRelease(node) 中释放锁。 发生在等待之前，确保线程在挂起时不持有锁。 等待锁的地方： 在 while (!isOnSyncQueue(node)) 循环中，通过 LockSupport.park(this) 挂起线程。 等待条件是 node 被转移到同步队列（由 signal() 触发）或被中断。 获取锁后的恢复： 在 acquireQueued(node, savedState) 中重新竞争并获取锁。 使用保存的 savedState 恢复锁的状态（例如重入次数）。 获取锁后，处理可能的清理和中断逻辑。 锁的流程如下 持有锁 ↓ 检查中断 → 中断抛异常退出 ↓ 创建等待节点 ↓ 释放锁 (fullyRelease) ↓ 循环等待 (LockSupport.park) ↓ 被唤醒/中断 → 检查中断状态 ↓ 重新获取锁 (acquireQueued) ↓ 清理取消节点 ↓ 处理中断 ↓ 返回 (持有锁) 也就是说在这行代码 int savedState = fullyRelease(node);会释放掉锁\n详细看一下这个方法，这个方法是aqs提供的java.util.concurrent.locks.AbstractQueuedSynchronizer#fullyRelease\n/** * 使用当前状态值调用 release 方法，并返回保存的状态。 * 若操作失败，则取消节点并抛出异常。 * @param node 等待中的条件节点 * @return 先前的同步状态 */ /** * Invokes release with current state value; returns saved state. * Cancels node and throws exception on failure. * @param node the condition node for this wait * @return previous sync state */ final int fullyRelease(Node node) { boolean failed = true; try { int savedState = getState(); if (release(savedState)) { failed = false; return savedState; } else { throw new IllegalMonitorStateException(); } } finally { if (failed) node.waitStatus = Node.CANCELLED; } } 会在if条件里执行java.util.concurrent.locks.AbstractQueuedSynchronizer#release方法，尝试释放锁\n/** * 以独占模式释放锁。若 {@link #tryRelease} 返回 true，则唤醒一个或多个线程。 * 此方法可用于实现 {@link Lock#unlock}。 * * @param arg 释放参数，该值会传递给 {@link #tryRelease}，但不会被额外解释，可用于表示任意含义。 * @return {@link #tryRelease} 方法的返回值。 */ /** * Releases in exclusive mode. Implemented by unblocking one or * more threads if {@link #tryRelease} returns true. * This method can be used to implement method {@link Lock#unlock}. * * @param arg the release argument. This value is conveyed to * {@link #tryRelease} but is otherwise uninterpreted and * can represent anything you like. * @return the value returned from {@link #tryRelease} */ @ReservedStackAccess public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null \u0026\u0026 h.waitStatus != 0) unparkSuccessor(h); return true; } return false; } 最终执行java.util.concurrent.locks.AbstractQueuedSynchronizer#tryRelease进行释放，由子类定义具体的释放逻辑，这个场景下最终调用java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryRelease进行的释放逻辑\n这么看下来，执行java.util.concurrent.locks.Condition#await()会将持有的锁释放掉，释放掉锁之后，其他等待获取锁的线程可以尝试获取锁，拿到锁之后尝试进行生产或者消费\n假如执行到java.util.concurrent.locks.Condition#signalAll，那么会发通知等待在pCondition或cCondition上的线程，唤醒等待，尝试获取锁，在put()或take()finally里，最终会释放锁，对应的condition被唤醒，尝试重新获取锁。\n只有这样在await会释放锁，lock+condition的组合才会有意义。\n总结 lock+condition结合，可以实现精准控制，准确通知线程，降低锁竞争和资源消耗，实现并发的生产消费模型\n其他 以前有问题，只能靠搜索引擎给答案，现在有了ai之后，可以向ai提问，ai可以给你做详细的解释，也不用自己苦哈哈的看和理解了。\n遇到不懂的，ai能给你做详细解释，开发的学习成本确实降低了\n但是ai浪潮席卷下，硅基如何干碎碳基，可能很快就会来临了。\n现在就是ai人类化，人类ai化，真的抽象\n","wordCount":"4576","inLanguage":"zh","datePublished":"2025-02-27T15:52:52+08:00","dateModified":"2025-02-27T15:52:52+08:00","author":{"@type":"Person","name":"since"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.thend03.com/posts/tech/java-producer-consumer-model/"},"publisher":{"@type":"Organization","name":"站在海边看远方","logo":{"@type":"ImageObject","url":"https://blog.thend03.com/img/logo.jpg"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.thend03.com/ accesskey=h title="thend03 (Alt + H)"><img src=https://blog.thend03.com/img/logo.jpg alt=logo aria-label=logo height=35>thend03</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://blog.thend03.com/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://blog.thend03.com/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://blog.thend03.com/archives/ title="⏱️ 归档"><span>⏱️ 归档</span></a></li><li><a href=https://blog.thend03.com/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://blog.thend03.com/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=https://blog.thend03.com/links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div class=post-password></div><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://blog.thend03.com/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://blog.thend03.com/posts/>📚文章</a>&nbsp;»&nbsp;<a href=https://blog.thend03.com/posts/tech/>👨🏻‍💻 技术</a></div><h1 class=post-title>Java实现生产者消费者模型</h1><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2025-02-27
&nbsp;&nbsp;
</span></span><span id=post_meta_style_2><span class="fa fa-calendar-plus-o"></span>
<span>&nbsp;更新于&nbsp;2025-02-27
&nbsp;|&nbsp;
</span></span><span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>4576字
&nbsp;&nbsp;
</span></span><span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>10分钟
&nbsp;&nbsp;
</span></span><span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>since
&nbsp;&nbsp;
</span></span><span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://blog.thend03.com/tags/java/ style=color:var(--secondary)!important>Java</a>
&nbsp;<a href=https://blog.thend03.com/tags/juc/ style=color:var(--secondary)!important>Juc</a>
</span></span></span></span><span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;
</span></span><span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script><script>let url=document.documentURI,dnsUrl="https://blog.thend03.com/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:"https://twikoo-e1f2-2yfafx14j-thend03s-projects.vercel.app/",region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e6%a1%88%e4%be%8b aria-label=案例>案例</a></li><li><a href=#%e5%88%86%e6%9e%90 aria-label=分析>分析</a><ul><li><a href=#%e4%bb%a3%e7%a0%81%e6%b5%8b%e8%af%95 aria-label=代码测试>代码测试</a></li><li><a href=#%e7%96%91%e9%97%ae aria-label=疑问>疑问</a><ul><li><a href=#%e9%97%ae%e9%a2%981 aria-label=问题1>问题1</a></li><li><a href=#%e9%97%ae%e9%a2%982 aria-label=问题2>问题2</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li><li><a href=#%e5%85%b6%e4%bb%96 aria-label=其他>其他</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=案例>案例<a hidden class=anchor aria-hidden=true href=#案例>#</a></h2><p>Java并发的时候，看到了一个关于生产者消费者的案例</p><p>一个producer类和一个consumer类，实现了Runnable接口，作为线程执行的任务</p><p>一个Queue类，实现了queue的put()和take操作，模拟了生产和消费2个动作</p><p>实现方式使用了ReentrantLock+Condition</p><p>这个示例代码的话，是可以实现多线程之间并发生产和消费的，多个线程共同操作一个Queue对象，可以实现队列满时生产等待，队列空时消费等待，且无并发问题。</p><p><strong>我当时产生的疑问是为什么使用了ReentrantLock，还要使用Condition</strong></p><p>这个问题下一个章节再说，先贴下示例代码</p><p>Producer</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Producer</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Runnable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>Producer</span><span class=p>(</span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>threadName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>getName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 隔10秒轮询生产一次</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Producer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>queue</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Random</span><span class=p>().</span><span class=na>nextInt</span><span class=p>(</span><span class=n>100</span><span class=p>),</span><span class=n>threadName</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Consumer</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Consumer</span><span class=w> </span><span class=kd>implements</span><span class=w> </span><span class=n>Runnable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>Consumer</span><span class=p>(</span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>threadName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>getName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 隔3秒轮询消费一次</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Customer&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>.</span><span class=na>sleep</span><span class=p>(</span><span class=n>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;取到的值-&#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>take</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Queue</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Queue</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arr</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>5</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>putIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  </span><span class=c1>// 生产位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>takeIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=c1>// 消费位置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>ReentrantLock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>pCondition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>cCondition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isEmpty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>size</span><span class=o>==</span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>isFull</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>size</span><span class=o>==</span><span class=n>5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=n>Integer</span><span class=w> </span><span class=n>value</span><span class=p>,</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ▶▶▶ 尝试获取锁...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ✅ 成功获取锁 | 当前锁状态: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>lock</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>isFull</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>log</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ⏸️ 队列已满，进入等待 (pCondition.await())...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>pCondition</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> </span><span class=c1>// 自动释放锁！</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>log</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 🔄 被唤醒，重新获取锁 | 当前锁状态: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>lock</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>arr</span><span class=o>[</span><span class=n>putIndex</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>putIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>putIndex</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>size</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 生产逻辑...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 🔔 生产完成，唤醒消费者 (cCondition.signalAll())&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cCondition</span><span class=p>.</span><span class=na>signalAll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ⏹️ 释放锁 | 当前锁状态: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>lock</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>take</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>threadName</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Thread</span><span class=p>.</span><span class=na>currentThread</span><span class=p>().</span><span class=na>getName</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>log</span><span class=p>(</span><span class=n>threadName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ▶▶▶ 尝试获取锁...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>(</span><span class=n>threadName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ✅ 成功获取锁 | 当前锁状态: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>lock</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>log</span><span class=p>(</span><span class=n>threadName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ⏸️ 队列为空，进入等待 (cCondition.await())...&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cCondition</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> </span><span class=c1>// 自动释放锁！</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>log</span><span class=p>(</span><span class=n>threadName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 🔄 被唤醒，重新获取锁 | 当前锁状态: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>lock</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arr</span><span class=o>[</span><span class=n>takeIndex</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>arr</span><span class=o>[</span><span class=n>takeIndex</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>  </span><span class=c1>// 可选：清理数据以便调试</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>takeIndex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>takeIndex</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=n>arr</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>size</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>(</span><span class=n>threadName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; 🔔 消费完成，唤醒生产者 (pCondition.signalAll())&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>pCondition</span><span class=p>.</span><span class=na>signalAll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>log</span><span class=p>(</span><span class=n>threadName</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s>&#34; ⏹️ 释放锁 | 当前锁状态: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>lock</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>log</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>printf</span><span class=p>(</span><span class=s>&#34;[%s] %s%n&#34;</span><span class=p>,</span><span class=w> </span><span class=n>LocalDateTime</span><span class=p>.</span><span class=na>now</span><span class=p>().</span><span class=na>format</span><span class=p>(</span><span class=n>DateTimeFormatter</span><span class=p>.</span><span class=na>ISO_LOCAL_TIME</span><span class=p>),</span><span class=w> </span><span class=n>message</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=分析>分析<a hidden class=anchor aria-hidden=true href=#分析>#</a></h2><h3 id=代码测试>代码测试<a hidden class=anchor aria-hidden=true href=#代码测试>#</a></h3><p>首先写了个测试类，测试了一下生产消费逻辑, 2个生产者，2个消费者，共4个线程，操作同一个queue，实现生产消费逻辑</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 两个生产者，两个消费者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Queue</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Queue</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=w> </span><span class=n>producer1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Producer</span><span class=p>(</span><span class=n>queue</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>producer1</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;Producer1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>producer1</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=w> </span><span class=n>producer2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Producer</span><span class=p>(</span><span class=n>queue</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>producer2</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;Producer2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>producer2</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=w> </span><span class=n>Consumer1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Consumer</span><span class=p>(</span><span class=n>queue</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Consumer1</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;Consumer1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Consumer1</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Thread</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Consumer</span><span class=p>(</span><span class=n>queue</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Consumer2</span><span class=p>.</span><span class=na>setName</span><span class=p>(</span><span class=s>&#34;Consumer2&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Consumer2</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>控制台部分输出内容如下</p><p>输出内容展示了尝试获取锁&mdash;->获取锁成功&mdash;->等待&mdash;->释放锁&mdash;->被唤醒&mdash;->重新获取锁&mdash;->生产/消费完成并唤醒等待的线程&mdash;->释放锁的这么一个过程</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>07</span><span class=p>.</span><span class=na>504</span><span class=o>]</span><span class=w> </span><span class=n>Consumer1</span><span class=w> </span><span class=err>▶▶▶</span><span class=w> </span><span class=n>尝试获取锁</span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>07</span><span class=p>.</span><span class=na>504</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>▶▶▶</span><span class=w> </span><span class=n>尝试获取锁</span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>07</span><span class=p>.</span><span class=na>516</span><span class=o>]</span><span class=w> </span><span class=n>Consumer1</span><span class=w> </span><span class=err>✅</span><span class=w> </span><span class=n>成功获取锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Locked</span><span class=w> </span><span class=n>by</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=n>Consumer1</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>07</span><span class=p>.</span><span class=na>516</span><span class=o>]</span><span class=w> </span><span class=n>Consumer1</span><span class=w> </span><span class=err>⏸</span><span class=n>️</span><span class=w> </span><span class=n>队列为空</span><span class=err>，</span><span class=n>进入等待</span><span class=w> </span><span class=p>(</span><span class=n>cCondition</span><span class=p>.</span><span class=na>await</span><span class=p>())...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>07</span><span class=p>.</span><span class=na>516</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>✅</span><span class=w> </span><span class=n>成功获取锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Locked</span><span class=w> </span><span class=n>by</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=n>Consumer2</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>07</span><span class=p>.</span><span class=na>516</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>⏸</span><span class=n>️</span><span class=w> </span><span class=n>队列为空</span><span class=err>，</span><span class=n>进入等待</span><span class=w> </span><span class=p>(</span><span class=n>cCondition</span><span class=p>.</span><span class=na>await</span><span class=p>())...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>5</span><span class=o>]</span><span class=w> </span><span class=n>Producer2</span><span class=w> </span><span class=err>▶▶▶</span><span class=w> </span><span class=n>尝试获取锁</span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>501</span><span class=o>]</span><span class=w> </span><span class=n>Producer2</span><span class=w> </span><span class=err>✅</span><span class=w> </span><span class=n>成功获取锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Locked</span><span class=w> </span><span class=n>by</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=n>Producer2</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>502</span><span class=o>]</span><span class=w> </span><span class=n>Producer2</span><span class=w> </span><span class=err>🔔</span><span class=w> </span><span class=n>生产完成</span><span class=err>，</span><span class=n>唤醒消费者</span><span class=w> </span><span class=p>(</span><span class=n>cCondition</span><span class=p>.</span><span class=na>signalAll</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>5</span><span class=o>]</span><span class=w> </span><span class=n>Producer1</span><span class=w> </span><span class=err>▶▶▶</span><span class=w> </span><span class=n>尝试获取锁</span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>502</span><span class=o>]</span><span class=w> </span><span class=n>Consumer1</span><span class=w> </span><span class=err>🔄</span><span class=w> </span><span class=n>被唤醒</span><span class=err>，</span><span class=n>重新获取锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Locked</span><span class=w> </span><span class=n>by</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=n>Consumer1</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>502</span><span class=o>]</span><span class=w> </span><span class=n>Producer2</span><span class=w> </span><span class=err>⏹</span><span class=n>️</span><span class=w> </span><span class=n>释放锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Unlocked</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Producer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>503</span><span class=o>]</span><span class=w> </span><span class=n>Consumer1</span><span class=w> </span><span class=err>🔔</span><span class=w> </span><span class=n>消费完成</span><span class=err>，</span><span class=n>唤醒生产者</span><span class=w> </span><span class=p>(</span><span class=n>pCondition</span><span class=p>.</span><span class=na>signalAll</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>504</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>🔄</span><span class=w> </span><span class=n>被唤醒</span><span class=err>，</span><span class=n>重新获取锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Locked</span><span class=w> </span><span class=n>by</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=n>Consumer2</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>504</span><span class=o>]</span><span class=w> </span><span class=n>Consumer1</span><span class=w> </span><span class=err>⏹</span><span class=n>️</span><span class=w> </span><span class=n>释放锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Unlocked</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>504</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>⏸</span><span class=n>️</span><span class=w> </span><span class=n>队列为空</span><span class=err>，</span><span class=n>进入等待</span><span class=w> </span><span class=p>(</span><span class=n>cCondition</span><span class=p>.</span><span class=na>await</span><span class=p>())...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>取到的值</span><span class=o>-</span><span class=n>68</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Customer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>504</span><span class=o>]</span><span class=w> </span><span class=n>Producer1</span><span class=w> </span><span class=err>✅</span><span class=w> </span><span class=n>成功获取锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Locked</span><span class=w> </span><span class=n>by</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=n>Producer1</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>505</span><span class=o>]</span><span class=w> </span><span class=n>Producer1</span><span class=w> </span><span class=err>🔔</span><span class=w> </span><span class=n>生产完成</span><span class=err>，</span><span class=n>唤醒消费者</span><span class=w> </span><span class=p>(</span><span class=n>cCondition</span><span class=p>.</span><span class=na>signalAll</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>505</span><span class=o>]</span><span class=w> </span><span class=n>Producer1</span><span class=w> </span><span class=err>⏹</span><span class=n>️</span><span class=w> </span><span class=n>释放锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Unlocked</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Producer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>505</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>🔄</span><span class=w> </span><span class=n>被唤醒</span><span class=err>，</span><span class=n>重新获取锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Locked</span><span class=w> </span><span class=n>by</span><span class=w> </span><span class=n>thread</span><span class=w> </span><span class=n>Consumer2</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>506</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>🔔</span><span class=w> </span><span class=n>消费完成</span><span class=err>，</span><span class=n>唤醒生产者</span><span class=w> </span><span class=p>(</span><span class=n>pCondition</span><span class=p>.</span><span class=na>signalAll</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>[</span><span class=n>16</span><span class=p>:</span><span class=n>14</span><span class=p>:</span><span class=n>14</span><span class=p>.</span><span class=na>506</span><span class=o>]</span><span class=w> </span><span class=n>Consumer2</span><span class=w> </span><span class=err>⏹</span><span class=n>️</span><span class=w> </span><span class=n>释放锁</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>当前锁状态</span><span class=p>:</span><span class=w> </span><span class=n>java</span><span class=p>.</span><span class=na>util</span><span class=p>.</span><span class=na>concurrent</span><span class=p>.</span><span class=na>locks</span><span class=p>.</span><span class=na>ReentrantLock</span><span class=nd>@363b2ca2</span><span class=o>[</span><span class=n>Unlocked</span><span class=o>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>取到的值</span><span class=o>-</span><span class=n>83</span><span class=w>
</span></span></span></code></pre></div><h3 id=疑问>疑问<a hidden class=anchor aria-hidden=true href=#疑问>#</a></h3><p>一开始由于对这快内容不是很了解，我产生了2个疑问，</p><ul><li>线程只要获取锁之后，其他线程都得等待获取锁，多个线程只用竞争一把锁，为什么要使用condition呢。</li><li>线程在获取锁之后，只能等待锁执行完释放才能重新竞争到锁，加了condition等待唤醒有什么用呢</li></ul><p>带着这2个疑问，我去问了deepseek和grok以及chatgpt，靠ai给思路，然后去看了代码，确认了使用condition的合理性和必要性</p><h4 id=问题1>问题1<a hidden class=anchor aria-hidden=true href=#问题1>#</a></h4><p>先看看grok怎么回答问题1的</p><p><strong>只使用lock</strong></p><p>单独使用 Lock 通常会通过忙等待（busy-waiting）或简单的条件检查来模拟生产者-消费者的同步</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Lock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>capacity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>put</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>queue</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>capacity</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w> </span><span class=c1>// 临时释放锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Thread</span><span class=p>.</span><span class=na>yield</span><span class=p>();</span><span class=w> </span><span class=c1>// 让出 CPU</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>   </span><span class=c1>// 重新获取锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>item</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>take</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>queue</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Thread</span><span class=p>.</span><span class=na>yield</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>只使用lock，会频繁判断条件，写出如上的加锁/释放锁的代码，以及要让出cpu，不够优雅</p><p><strong>结合lock+condition</strong></p><p>使用 Lock 和 Condition，可以通过条件变量精确控制线程的等待和唤醒</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Lock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Condition</span><span class=w> </span><span class=n>pCondition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Condition</span><span class=w> </span><span class=n>cCondition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kt>int</span><span class=w> </span><span class=n>capacity</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>10</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>produce</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>queue</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>capacity</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>pCondition</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> </span><span class=c1>// 等待“非满”条件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>item</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cCondition</span><span class=p>.</span><span class=na>signal</span><span class=p>();</span><span class=w> </span><span class=c1>// 唤醒等待“非空”的消费者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>consume</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lock</span><span class=p>.</span><span class=na>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>queue</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cCondition</span><span class=p>.</span><span class=na>await</span><span class=p>();</span><span class=w> </span><span class=c1>// 等待“非空”条件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>queue</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pCondition</span><span class=p>.</span><span class=na>signal</span><span class=p>();</span><span class=w> </span><span class=c1>// 唤醒等待“非满”的生产者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>lock</span><span class=p>.</span><span class=na>unlock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>lock+condition，可以精准控制线程的等待和唤醒</p><p>使用了2个condition，queue满了pCondition就等待，暂停生产，queue空了cCondition就等待，暂停消费</p><p>生产之后， 释放信号，唤醒cCondition去消费，消费之后，唤醒pCondition去生产</p><p><strong>2种实现方式优缺点比较</strong></p><table><thead><tr><th>特性</th><th>只使用 Lock</th><th>使用 Lock + Condition</th></tr></thead><tbody><tr><td><strong>线程通知</strong></td><td>无法精确通知，依赖轮询</td><td>精确通知，通过 signal() 唤醒</td></tr><tr><td><strong>效率</strong></td><td>忙等待或频繁锁切换，效率低</td><td>线程挂起，无忙等待，效率高</td></tr><tr><td><strong>锁竞争</strong></td><td>高，可能反复释放和获取锁</td><td>低，唤醒后队列式获取锁</td></tr><tr><td><strong>代码复杂度</strong></td><td>高，手动实现等待逻辑</td><td>低，API 简洁且功能强大</td></tr><tr><td><strong>条件区分</strong></td><td>无法区分不同条件</td><td>支持多个 Condition 对象</td></tr><tr><td><strong>中断处理</strong></td><td>手动检查和处理</td><td>内置支持，抛出异常</td></tr></tbody></table><p>通过以上的优缺点比较，可以看到单独使用lock，有以下缺点</p><ul><li>缺乏精确的线程通知机制</li><li>效率低下，忙等待或锁切换开销大。</li><li>更高的锁竞争和延迟。</li><li>代码复杂且不够优雅。</li><li>无法区分不同等待条件。</li><li>中断处理困难。</li></ul><p>在实际的生产场景种</p><p>假设一个高并发生产者-消费者系统：</p><ul><li>只使用 Lock<ul><li>缓冲区满时，生产者线程不断轮询，浪费 CPU。</li><li>消费者被唤醒后可能发现缓冲区仍空（其他消费者抢先消费），需要再次等待。</li><li>系统吞吐量低，延迟高。</li></ul></li><li>使用 Lock + Condition<ul><li>生产者等待 pCondition，消费者等待 cCondition，互不干扰。</li><li>生产者放入数据后只唤醒消费者，消费者移除数据后只唤醒生产者。</li><li>系统高效运行，资源利用率高。</li></ul></li></ul><h4 id=问题2>问题2<a hidden class=anchor aria-hidden=true href=#问题2>#</a></h4><p>再看看问题2的回答</p><p>获取condition使用的是lock的api，返回的是定义在aqs中的conditionobject</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=n>ReentrantLock</span><span class=w> </span><span class=n>lock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ReentrantLock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>pCondition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>Condition</span><span class=w> </span><span class=n>cCondition</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>lock</span><span class=p>.</span><span class=na>newCondition</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/thend03/mdPic/picGo/202502271722889.png alt=image-20250227172213797></p><p>调用<code>pCondition.await(); </code>实际是调用了<code>java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject#await()</code></p><p>我将aqs的方法代码，喂给了grok，让grok帮我分析方法实现的细节</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 实现可中断的条件等待。
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;ol&gt;
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;li&gt; 如果当前线程被中断，则抛出 InterruptedException 异常。
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;li&gt; 保存由 {@link #getState} 返回的锁状态。
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;li&gt; 使用保存的状态作为参数调用 {@link #release} 方法，
</span></span></span><span class=line><span class=cl><span class=cm> *      如果失败则抛出 IllegalMonitorStateException 异常。
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;li&gt; 阻塞，直到被唤醒或被中断。
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;li&gt; 通过调用 {@link #acquire} 的特定版本，并传入保存的状态作为参数来重新获取锁。
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;li&gt; 如果在第 4 步阻塞时被中断，则抛出 InterruptedException 异常。
</span></span></span><span class=line><span class=cl><span class=cm> * &lt;/ol&gt;
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>         * Implements interruptible condition wait.
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;ol&gt;
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;li&gt; Save lock state returned by {@link #getState}.
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;li&gt; Invoke {@link #release} with saved state as argument,
</span></span></span><span class=line><span class=cl><span class=cm>         *      throwing IllegalMonitorStateException if it fails.
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;li&gt; Block until signalled or interrupted.
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;li&gt; Reacquire by invoking specialized version of
</span></span></span><span class=line><span class=cl><span class=cm>         *      {@link #acquire} with saved state as argument.
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.
</span></span></span><span class=line><span class=cl><span class=cm>         * &lt;/ol&gt;
</span></span></span><span class=line><span class=cl><span class=cm>         */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>await</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>interrupted</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InterruptedException</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Node</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>addConditionWaiter</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>           </span><span class=c1>//释放锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>savedState</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>fullyRelease</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>interruptMode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>isOnSyncQueue</span><span class=p>(</span><span class=n>node</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>LockSupport</span><span class=p>.</span><span class=na>park</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>interruptMode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>checkInterruptWhileWaiting</span><span class=p>(</span><span class=n>node</span><span class=p>))</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>acquireQueued</span><span class=p>(</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>savedState</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>interruptMode</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>THROW_IE</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>interruptMode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>REINTERRUPT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=p>.</span><span class=na>nextWaiter</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=c1>// clean up if cancelled</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>unlinkCancelledWaiters</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>interruptMode</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>reportInterruptAfterWait</span><span class=p>(</span><span class=n>interruptMode</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>grok帮我总结出了如下重点</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>锁的释放</span><span class=err>：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>在</span><span class=w> </span><span class=nf>fullyRelease</span><span class=p>(</span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=n>中释放锁</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>发生在等待之前</span><span class=err>，</span><span class=n>确保线程在挂起时不持有锁</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>等待锁的地方</span><span class=err>：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>在</span><span class=w> </span><span class=nf>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>isOnSyncQueue</span><span class=p>(</span><span class=n>node</span><span class=p>))</span><span class=w> </span><span class=n>循环中</span><span class=err>，</span><span class=n>通过</span><span class=w> </span><span class=n>LockSupport</span><span class=p>.</span><span class=na>park</span><span class=p>(</span><span class=k>this</span><span class=p>)</span><span class=w> </span><span class=n>挂起线程</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>等待条件是</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=n>被转移到同步队列</span><span class=err>（</span><span class=n>由</span><span class=w> </span><span class=nf>signal</span><span class=p>()</span><span class=w> </span><span class=n>触发</span><span class=err>）</span><span class=n>或被中断</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>获取锁后的恢复</span><span class=err>：</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>在</span><span class=w> </span><span class=nf>acquireQueued</span><span class=p>(</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>savedState</span><span class=p>)</span><span class=w> </span><span class=n>中重新竞争并获取锁</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>使用保存的</span><span class=w> </span><span class=n>savedState</span><span class=w> </span><span class=n>恢复锁的状态</span><span class=err>（</span><span class=n>例如重入次数</span><span class=err>）。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>获取锁后</span><span class=err>，</span><span class=n>处理可能的清理和中断逻辑</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>锁的流程如下</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>持有锁</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>检查中断</span><span class=w> </span><span class=err>→</span><span class=w> </span><span class=n>中断抛异常退出</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>创建等待节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>释放锁</span><span class=w> </span><span class=p>(</span><span class=n>fullyRelease</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>循环等待</span><span class=w> </span><span class=p>(</span><span class=n>LockSupport</span><span class=p>.</span><span class=na>park</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>被唤醒</span><span class=o>/</span><span class=n>中断</span><span class=w> </span><span class=err>→</span><span class=w> </span><span class=n>检查中断状态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>重新获取锁</span><span class=w> </span><span class=p>(</span><span class=n>acquireQueued</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>清理取消节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>处理中断</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>↓</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>返回</span><span class=w> </span><span class=p>(</span><span class=n>持有锁</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><p>也就是说在这行代码<code> int savedState = fullyRelease(node);</code>会释放掉锁</p><p>详细看一下这个方法，这个方法是aqs提供的<code>java.util.concurrent.locks.AbstractQueuedSynchronizer#fullyRelease</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>
</span></span></span><span class=line><span class=cl><span class=cm>* 使用当前状态值调用 release 方法，并返回保存的状态。
</span></span></span><span class=line><span class=cl><span class=cm>* 若操作失败，则取消节点并抛出异常。
</span></span></span><span class=line><span class=cl><span class=cm>* @param node 等待中的条件节点
</span></span></span><span class=line><span class=cl><span class=cm>* @return 先前的同步状态
</span></span></span><span class=line><span class=cl><span class=cm>*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Invokes release with current state value; returns saved state.
</span></span></span><span class=line><span class=cl><span class=cm>     * Cancels node and throws exception on failure.
</span></span></span><span class=line><span class=cl><span class=cm>     * @param node the condition node for this wait
</span></span></span><span class=line><span class=cl><span class=cm>     * @return previous sync state
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>fullyRelease</span><span class=p>(</span><span class=n>Node</span><span class=w> </span><span class=n>node</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>boolean</span><span class=w> </span><span class=n>failed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>savedState</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>getState</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>release</span><span class=p>(</span><span class=n>savedState</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>failed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=n>savedState</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>IllegalMonitorStateException</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>failed</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>node</span><span class=p>.</span><span class=na>waitStatus</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Node</span><span class=p>.</span><span class=na>CANCELLED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>会在if条件里执行<code>java.util.concurrent.locks.AbstractQueuedSynchronizer#release</code>方法，尝试释放锁</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**  
</span></span></span><span class=line><span class=cl><span class=cm> * 以独占模式释放锁。若 {@link #tryRelease} 返回 true，则唤醒一个或多个线程。  
</span></span></span><span class=line><span class=cl><span class=cm> * 此方法可用于实现 {@link Lock#unlock}。  
</span></span></span><span class=line><span class=cl><span class=cm> *  
</span></span></span><span class=line><span class=cl><span class=cm> * @param arg 释放参数，该值会传递给 {@link #tryRelease}，但不会被额外解释，可用于表示任意含义。  
</span></span></span><span class=line><span class=cl><span class=cm> * @return {@link #tryRelease} 方法的返回值。  
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * Releases in exclusive mode.  Implemented by unblocking one or
</span></span></span><span class=line><span class=cl><span class=cm>     * more threads if {@link #tryRelease} returns true.
</span></span></span><span class=line><span class=cl><span class=cm>     * This method can be used to implement method {@link Lock#unlock}.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * @param arg the release argument.  This value is conveyed to
</span></span></span><span class=line><span class=cl><span class=cm>     *        {@link #tryRelease} but is otherwise uninterpreted and
</span></span></span><span class=line><span class=cl><span class=cm>     *        can represent anything you like.
</span></span></span><span class=line><span class=cl><span class=cm>     * @return the value returned from {@link #tryRelease}
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ReservedStackAccess</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>release</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>arg</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>tryRelease</span><span class=p>(</span><span class=n>arg</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Node</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>head</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>h</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>h</span><span class=p>.</span><span class=na>waitStatus</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>unparkSuccessor</span><span class=p>(</span><span class=n>h</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>最终执行<code>java.util.concurrent.locks.AbstractQueuedSynchronizer#tryRelease</code>进行释放，由子类定义具体的释放逻辑，这个场景下最终调用<code>java.util.concurrent.locks.ReentrantReadWriteLock.Sync#tryRelease</code>进行的释放逻辑</p><p>这么看下来，执行<code>java.util.concurrent.locks.Condition#await()</code>会将持有的锁释放掉，释放掉锁之后，其他等待获取锁的线程可以尝试获取锁，拿到锁之后尝试进行生产或者消费</p><p>假如执行到<code>java.util.concurrent.locks.Condition#signalAll</code>，那么会发通知等待在pCondition或cCondition上的线程，唤醒等待，尝试获取锁，在put()或take()finally里，最终会释放锁，对应的condition被唤醒，尝试重新获取锁。</p><p>只有这样在await会释放锁，lock+condition的组合才会有意义。</p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>lock+condition结合，可以实现精准控制，准确通知线程，降低锁竞争和资源消耗，实现并发的生产消费模型</p><h2 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h2><p>以前有问题，只能靠搜索引擎给答案，现在有了ai之后，可以向ai提问，ai可以给你做详细的解释，也不用自己苦哈哈的看和理解了。</p><p>遇到不懂的，ai能给你做详细解释，开发的学习成本确实降低了</p><p>但是ai浪潮席卷下，硅基如何干碎碳基，可能很快就会来临了。</p><p>现在就是ai人类化，人类ai化，真的抽象</p></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://blog.thend03.com/img/wechat-pay.png alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://blog.thend03.com/img/alipay.png alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.thend03.com/posts/watched-movies-250304/><span class=title>« 上一页</span><br><span>近期看过的影视剧</span>
</a><a class=next href=https://blog.thend03.com/posts/life/zhuge-fairy-mount/><span class=title>下一页 »</span><br><span>江浙沪周边游之诸葛仙山</span></a></nav></footer></div><script>function createGiscusScript(e){const t=document.createElement("script");Object.entries(e).forEach(([e,n])=>t.setAttribute(e,n)),document.querySelector("article").appendChild(t);const n=document.querySelector('label[for="switch_default"]');n&&n.addEventListener("click",function(){const e=document.body.classList.contains("dark")?"transparent_dark":"light";t.setAttribute("data-theme",e),sendMessage({setConfig:{theme:e}})})}function sendMessage(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}document.addEventListener("DOMContentLoaded",function(){const e={src:"https://giscus.app/client.js","data-repo":"thend03/blog-comments","data-repo-id":"R_kgDOJx0ckg","data-category":"Announcements","data-category-id":"DIC_kwDOJx0cks4CmM8j","data-mapping":"pathname","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous",async:""};e["data-theme"]=document.body.classList.contains("dark")?"transparent_dark":"light",createGiscusScript(e);const t=new MutationObserver(()=>{const e=document.body.classList.contains("dark")?"transparent_dark":"light";sendMessage({setConfig:{theme:e}})});t.observe(document.body,{attributes:!0,attributeFilter:["class"]})})</script></article></main><footer class=footer><span>Copyright
&copy;
2020-2025
<a href=https://blog.thend03.com/ style=color:#939393>站在海边看远方</a>
All Rights Reserved
</span><a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;
<span><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style=display:inline-block;text-decoration:none;height:20px;color:#939393><img src style="float:left;margin:0 5px 0 0">
</a></span><span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString(),s=window.getSelection().toString();t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>