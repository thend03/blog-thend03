<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何解决java.util.ConcurrentModificationException问题 | 站在海边看远方</title>
<meta name=keywords content="java,juc,exception"><meta name=description content="如何解决java.util.ConcurrentModificationException问题"><meta name=author content="since"><link rel=canonical href=https://blog.thend03.com/posts/how-to-fix-java.util.concurrentmodificationexception/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://blog.thend03.com/img/logo.jpg><link rel=icon type=image/png sizes=16x16 href=https://blog.thend03.com/img/logo.jpg><link rel=icon type=image/png sizes=32x32 href=https://blog.thend03.com/img/logo.jpg><link rel=apple-touch-icon href=https://blog.thend03.com/img/logo.jpg><link rel=mask-icon href=https://blog.thend03.com/img/logo.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.thend03.com/posts/how-to-fix-java.util.concurrentmodificationexception/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css><script src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><script src=https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><meta property="og:title" content="如何解决java.util.ConcurrentModificationException问题"><meta property="og:description" content="如何解决java.util.ConcurrentModificationException问题"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.thend03.com/posts/how-to-fix-java.util.concurrentmodificationexception/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-26T17:07:58+08:00"><meta property="article:modified_time" content="2024-07-26T17:07:58+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="如何解决java.util.ConcurrentModificationException问题"><meta name=twitter:description content="如何解决java.util.ConcurrentModificationException问题"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://blog.thend03.com/posts/"},{"@type":"ListItem","position":2,"name":"如何解决java.util.ConcurrentModificationException问题","item":"https://blog.thend03.com/posts/how-to-fix-java.util.concurrentmodificationexception/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何解决java.util.ConcurrentModificationException问题","name":"如何解决java.util.ConcurrentModificationException问题","description":"如何解决java.util.ConcurrentModificationException问题","keywords":["java","juc","exception"],"articleBody":"问题 最近在debug的时候，莫名奇妙的会遇到java.util.ConcurrentModificationException问题。\n根据我的历史经验，发生这种问题肯定是for循环里调了remove或者add。\n但是看了一圈代码，没发现此类操作，有点蒙圈，这是为啥。。。\n根因分析 平常遇到的java.util.ConcurrentModificationException大多是下面的第一种，迭代器遍历和集合类的add/remove方法同时调用了。\n像增强for循环底层也属于迭代器遍历，所以这种错误是比较常见的。\n我这次遇到的就真的是多线程场景下的并发修改错误。\n并发修改错误原因分析 java.util.ArrayList.Itr是ArrayList的内部类，expectedModCount是属于Itr的成员变量。\nmodCount是java.util.AbstractList的成员变量。\n首先看一下Itr类的定义\n/** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator\u003cE\u003e { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } //省略其他代码 } 在生成迭代器Itr的时候，expectedModCount相当于是拿的当前ArrayList的modCount的值。\n后续list.add()或者list.remove()只会修改modCount，expectedModCount是不会受list.add()或者list.remove()影响的。\n再进行迭代器遍历的时候就会抛出java.util.ConcurrentModificationException。\n迭代器和集合类方法同时使用 java的集合类有如下2个字段, 翻译过来就是expectedModCount!=modCount的时候，会抛出并发异常。\n期望是修改的数量和期望值相同的，不同的时候肯定是有问题了。\n/** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; 像如下这种写法，肯定会抛出java.util.ConcurrentModificationException异常的。\n因为for循环底层是使用的迭代器,这种情况就会导致并发修改错误。\npublic static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); for (String a : list) { System.out.println(a); list.remove(0); } } 这段代码编译为class，结果如下, 可以看到for循环变成了iterator迭代遍历。\n遍历是使用的iterator，但是remove方法是集合类的自己的方法。\npublic static void main(String[] args) { List\u003cString\u003e list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); Iterator var2 = list.iterator(); while(var2.hasNext()) { String a = (String)var2.next(); System.out.println(a); list.remove(0); } } java.util.ArrayList.Itr#next迭代器的next会先校验modCount != expectedModCount, 2个值不相等就抛出异常\n@SuppressWarnings(\"unchecked\") public E next() { checkForComodification(); int i = cursor; if (i \u003e= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u003e= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 正常使用迭代器的话modCount == expectedModCount，这种情况是不会抛异常的。\n但是list.remove(0)，会修改modCount，而不修expectedModCount,导致下一次迭代报错\npublic E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved \u003e 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 总结一下就是:\n迭代器遍历不能和集合类自身的add/remove方法一起调用，这样会导致modCount和expectedModCount不相等，从而抛出java.util.ConcurrentModificationException。\nadd/remove都是集合类自身的方法，都只修改modCount而不修改expectedModCount\n并发修改导致的异常 之前遇到的都是上面一种导致的异常，这次真的就遇到多线程场景下的java.util.ConcurrentModificationException了。\n看一下下面的代码\npublic static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); Thread thread = new Thread(() -\u003e list.forEach(a -\u003e { System.out.println(a); })); thread.start(); Thread thread1 = new Thread(() -\u003e list.sort((o1, o2) -\u003e o2.length() - o1.length())); thread1.start(); } 这段代码直接执行是没有问题的，可以正常结束，但是稍微修改一下，加点延迟，就会有问题了\npublic static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); Thread thread = new Thread(() -\u003e list.forEach(a -\u003e { try { Thread.sleep(50); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(a); })); thread.start(); Thread thread1 = new Thread(() -\u003e list.sort((o1, o2) -\u003e o2.length() - o1.length())); thread1.start(); } //运行异常 Exception in thread \"Thread-0\" java.util.ConcurrentModificationException at java.util.ArrayList.forEach(ArrayList.java:1262) at com.fc.se.list.ListTest.lambda$main$1(ListTest.java:23) at java.lang.Thread.run(Thread.java:750) 看异常堆栈是java.util.ArrayList#forEach方法, 会校验modCount != expectedModCount，不符合预期就报错\n@Override public void forEach(Consumer\u003c? super E\u003e action) { Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount \u0026\u0026 i \u003c size; i++) { action.accept(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 现在这个场景变成了在2个线程里对同一个list进行遍历和sort操作.\n看下sort操作\n@Override @SuppressWarnings(\"unchecked\") public void sort(Comparator\u003c? super E\u003e c) { final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } modCount++; } 这2个代码放一起比较一下就可以看出端倪了，sort()会修改modeCount, 但是不会修改expectedModCount。\n再次进行list.foreach()时，由于modCount != expectedModCount，就会抛出ConcurrentModificationException。\n如果不加Thread.sleep(50);，thread会迅速执行完成，相当于2个线程串行执行，所以不会有并发修改问题。\n加了Thread.sleep(50);，2个线程会并发执行，就会抛异常了。\n解决方式 第一种，避免在迭代器里执行add/remove操作，如果需要在遍历的过程中修改集合，记得使用迭代器进行操作\n第二种也可以归类为迭代器和集合的操作，这种首先也需要避免迭代器和遍历一起操作, 另外多线程需要确保线程安全，按实际情况加锁。\nFail-Fast 上面的栗子就是fail-fast的一种场景，不符合预期，直接报错。\n什么是fail-fast 首先我们看下维基百科中关于fail-fast的解释：\nIn systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.\n大概意思是：在系统设计中，快速失效系统一种可以立即报告任何可能表明故障的情况的系统。\n快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。\n这种设计通常会在操作中的多个点检查系统的状态，因此可以及早检测到任何故障。\n快速失败模块的职责是检测错误，然后让系统的下一个最高级别处理错误。\n其实，这是一种理念，说白了就是在做系统设计的时候先考虑异常情况，一旦发生异常，直接停止并上报。\nFail-Safe 与之相对的还有fail-safe，这是一种并发安全机制。\n为了避免触发fail-fast机制，导致异常，我们可以使用Java中提供的一些采用了fail-safe机制的集合类。\n这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。\njava.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove 。\n参考文章 一不小心就踩坑的fail-fast是个什么鬼?\n","wordCount":"2853","inLanguage":"zh","datePublished":"2024-07-26T17:07:58+08:00","dateModified":"2024-07-26T17:07:58+08:00","author":{"@type":"Person","name":"since"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.thend03.com/posts/how-to-fix-java.util.concurrentmodificationexception/"},"publisher":{"@type":"Organization","name":"站在海边看远方","logo":{"@type":"ImageObject","url":"https://blog.thend03.com/img/logo.jpg"}}}</script></head><body id=top><script>(function(){let e,t=new RegExp("(^| )change-themes=([^;]*)(;|$)");(e=document.cookie.match(t))||((new Date).getHours()>=19||(new Date).getHours()<6?(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark")):(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")))})(),localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.thend03.com/ accesskey=h title="fayy&amp;fc (Alt + H)"><img src=https://blog.thend03.com/img/logo.jpg alt=logo aria-label=logo height=35>fayy&amp;fc</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://blog.thend03.com/search title="🔍 搜索 (Alt + /)" accesskey=/><span>🔍 搜索</span></a></li><li><a href=https://blog.thend03.com/ title="🏠 主页"><span>🏠 主页</span></a></li><li><a href=https://blog.thend03.com/archives/ title="⏱️ 归档"><span>⏱️ 归档</span></a></li><li><a href=https://blog.thend03.com/tags title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://blog.thend03.com/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li><li><a href=https://blog.thend03.com/links title="🤝 友链"><span>🤝 友链</span></a></li></ul></nav></header><main class="main page"><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}</style><article class=post-single><div id=single-content><header class=post-header><div class=breadcrumbs><a href=https://blog.thend03.com/>🏠 主页</a>&nbsp;»&nbsp;<a href=https://blog.thend03.com/posts/>📚文章</a></div><h1 class=post-title>如何解决java.util.ConcurrentModificationException问题</h1><div class=post-description>如何解决java.util.ConcurrentModificationException问题</div><div class=post-meta><style>i[id*=post_meta_style]{display:flex;align-items:center;margin:0 0 10px}.parent-post-meta{display:flex;flex-wrap:wrap;opacity:.8}</style><span class=parent-post-meta><span id=post_meta_style_1><span class="fa fa-calendar-check-o"></span>
<span>2024-07-26
&nbsp;&nbsp;
</span></span><span id=post_meta_style_3><span class="fa fa-file-word-o"></span>
<span>2853字
&nbsp;&nbsp;
</span></span><span id=post_meta_style_4><span class="fa fa-clock-o"></span>
<span>6分钟
&nbsp;&nbsp;
</span></span><span id=post_meta_style_5><span class="fa fa-user-o"></span>
<span>since
&nbsp;&nbsp;
</span></span><span id=post_meta_style_6><span class="fa fa-tags" style=opacity:.8></span>
<span><span class=post-tags-meta><a href=https://blog.thend03.com/tags/java/ style=color:var(--secondary)!important>Java</a>
&nbsp;<a href=https://blog.thend03.com/tags/juc/ style=color:var(--secondary)!important>Juc</a>
&nbsp;<a href=https://blog.thend03.com/tags/exception/ style=color:var(--secondary)!important>Exception</a>
</span></span></span></span><span style=opacity:.8><span id=post_meta_style_7>&nbsp;&nbsp;
<span class="fa fa-eye"></span>
<span><span id=busuanzi_container_page_pv><span id=busuanzi_value_page_pv></span></span>
&nbsp;&nbsp;
</span></span><span id=post_meta_style_8><span class="fa fa-commenting-o"></span>
<span><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script><script>let url=document.documentURI,dnsUrl="https://blog.thend03.com/",urlSplit=url.split(dnsUrl),finalUrl=urlSplit[1];finalUrl[0]!=="/"&&(finalUrl="/"+finalUrl),twikoo.getCommentsCount({envId:"https://twikoo-e1f2-2yfafx14j-thend03s-projects.vercel.app/",region:null,urls:[finalUrl],includeReply:!1}).then(function(e){let t=e[0].count;const n=document.getElementById("comment_count");n.innerText=t}).catch(function(e){console.error(e)})</script><span id=comment_count></span></span></span></span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e9%97%ae%e9%a2%98 aria-label=问题>问题</a></li><li><a href=#%e6%a0%b9%e5%9b%a0%e5%88%86%e6%9e%90 aria-label=根因分析>根因分析</a><ul><li><a href=#%e5%b9%b6%e5%8f%91%e4%bf%ae%e6%94%b9%e9%94%99%e8%af%af%e5%8e%9f%e5%9b%a0%e5%88%86%e6%9e%90 aria-label=并发修改错误原因分析>并发修改错误原因分析</a></li><li><a href=#%e8%bf%ad%e4%bb%a3%e5%99%a8%e5%92%8c%e9%9b%86%e5%90%88%e7%b1%bb%e6%96%b9%e6%b3%95%e5%90%8c%e6%97%b6%e4%bd%bf%e7%94%a8 aria-label=迭代器和集合类方法同时使用>迭代器和集合类方法同时使用</a></li><li><a href=#%e5%b9%b6%e5%8f%91%e4%bf%ae%e6%94%b9%e5%af%bc%e8%87%b4%e7%9a%84%e5%bc%82%e5%b8%b8 aria-label=并发修改导致的异常>并发修改导致的异常</a></li></ul></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e5%bc%8f aria-label=解决方式>解决方式</a></li><li><a href=#fail-fast aria-label=Fail-Fast>Fail-Fast</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%affail-fast aria-label=什么是fail-fast>什么是fail-fast</a></li></ul></li><li><a href=#fail-safe aria-label=Fail-Safe>Fail-Safe</a></li><li><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%ab%a0 aria-label=参考文章>参考文章</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{elements&&(activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h2><p>最近在debug的时候，莫名奇妙的会遇到<code>java.util.ConcurrentModificationException</code>问题。</p><p>根据我的历史经验，发生这种问题肯定是for循环里调了remove或者add。</p><p>但是看了一圈代码，没发现此类操作，有点蒙圈，这是为啥。。。</p><h2 id=根因分析>根因分析<a hidden class=anchor aria-hidden=true href=#根因分析>#</a></h2><p>平常遇到的<code>java.util.ConcurrentModificationException</code>大多是下面的第一种，迭代器遍历和集合类的add/remove方法同时调用了。</p><p>像增强for循环底层也属于迭代器遍历，所以这种错误是比较常见的。</p><p>我这次遇到的就真的是多线程场景下的并发修改错误。</p><h3 id=并发修改错误原因分析>并发修改错误原因分析<a hidden class=anchor aria-hidden=true href=#并发修改错误原因分析>#</a></h3><p><code>java.util.ArrayList.Itr</code>是ArrayList的内部类，expectedModCount是属于Itr的成员变量。</p><p>modCount是<code>java.util.AbstractList</code>的成员变量。</p><p>首先看一下Itr类的定义</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * An optimized version of AbstractList.Itr
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Itr</span> <span style=color:#66d9ef>implements</span> Iterator<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> cursor;       <span style=color:#75715e>// index of next element to return</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> lastRet <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1; <span style=color:#75715e>// index of last element returned; -1 if no such</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> expectedModCount <span style=color:#f92672>=</span> modCount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Itr() {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>hasNext</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> cursor <span style=color:#f92672>!=</span> size;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>       <span style=color:#75715e>//省略其他代码</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>在生成迭代器Itr的时候，expectedModCount相当于是拿的当前ArrayList的modCount的值。</p><p>后续list.add()或者list.remove()只会修改modCount，expectedModCount是不会受list.add()或者list.remove()影响的。</p><p>再进行迭代器遍历的时候就会抛出<code>java.util.ConcurrentModificationException</code>。</p><h3 id=迭代器和集合类方法同时使用>迭代器和集合类方法同时使用<a hidden class=anchor aria-hidden=true href=#迭代器和集合类方法同时使用>#</a></h3><p>java的集合类有如下2个字段, 翻译过来就是expectedModCount!=modCount的时候，会抛出并发异常。</p><p>期望是修改的数量和期望值相同的，不同的时候肯定是有问题了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * The modCount value that the iterator believes that the backing
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * List should have.  If this expectation is violated, the iterator
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * has detected concurrent modification.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> expectedModCount <span style=color:#f92672>=</span> modCount;
</span></span></code></pre></div><p>像如下这种写法，肯定会抛出<code>java.util.ConcurrentModificationException</code>异常的。</p><p>因为for循环底层是使用的迭代器,这种情况就会导致并发修改错误。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;a&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;b&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;c&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;d&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;e&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (String a : list) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a);
</span></span><span style=display:flex><span>            list.<span style=color:#a6e22e>remove</span>(0);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这段代码编译为class，结果如下, 可以看到for循环变成了iterator迭代遍历。</p><p>遍历是使用的iterator，但是remove方法是集合类的自己的方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList();
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;a&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;b&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;c&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;d&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;e&#34;</span>);
</span></span><span style=display:flex><span>        Iterator var2 <span style=color:#f92672>=</span> list.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(var2.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>            String a <span style=color:#f92672>=</span> (String)var2.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a);
</span></span><span style=display:flex><span>            list.<span style=color:#a6e22e>remove</span>(0);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><code>java.util.ArrayList.Itr#next</code>迭代器的next会先校验modCount != expectedModCount, 2个值不相等就抛出异常</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> E <span style=color:#a6e22e>next</span>() {
</span></span><span style=display:flex><span>  checkForComodification();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> cursor;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> size)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NoSuchElementException();
</span></span><span style=display:flex><span>  Object<span style=color:#f92672>[]</span> elementData <span style=color:#f92672>=</span> ArrayList.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>elementData</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;=</span> elementData.<span style=color:#a6e22e>length</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ConcurrentModificationException();
</span></span><span style=display:flex><span>  cursor <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> 1;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (E) elementData<span style=color:#f92672>[</span>lastRet <span style=color:#f92672>=</span> i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkForComodification</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (modCount <span style=color:#f92672>!=</span> expectedModCount)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ConcurrentModificationException();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>正常使用迭代器的话modCount == expectedModCount，这种情况是不会抛异常的。</p><p>但是list.remove(0)，会修改modCount，而不修expectedModCount,导致下一次迭代报错</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> E <span style=color:#a6e22e>remove</span>(<span style=color:#66d9ef>int</span> index) {
</span></span><span style=display:flex><span>        rangeCheck(index);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        modCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        E oldValue <span style=color:#f92672>=</span> elementData(index);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> numMoved <span style=color:#f92672>=</span> size <span style=color:#f92672>-</span> index <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (numMoved <span style=color:#f92672>&gt;</span> 0)
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>arraycopy</span>(elementData, index<span style=color:#f92672>+</span>1, elementData, index,
</span></span><span style=display:flex><span>                             numMoved);
</span></span><span style=display:flex><span>        elementData<span style=color:#f92672>[--</span>size<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>; <span style=color:#75715e>// clear to let GC do its work</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> oldValue;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>总结一下就是:</p><blockquote><p>迭代器遍历不能和集合类自身的add/remove方法一起调用，这样会导致modCount和expectedModCount不相等，从而抛出<code>java.util.ConcurrentModificationException</code>。</p><p>add/remove都是集合类自身的方法，都只修改modCount而不修改expectedModCount</p></blockquote><h3 id=并发修改导致的异常>并发修改导致的异常<a hidden class=anchor aria-hidden=true href=#并发修改导致的异常>#</a></h3><p>之前遇到的都是上面一种导致的异常，这次真的就遇到多线程场景下的<code>java.util.ConcurrentModificationException</code>了。</p><p>看一下下面的代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;a&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;b&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;c&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;d&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;e&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> list.<span style=color:#a6e22e>forEach</span>(a <span style=color:#f92672>-&gt;</span> { System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a); }));
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Thread thread1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> list.<span style=color:#a6e22e>sort</span>((o1, o2) <span style=color:#f92672>-&gt;</span> o2.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>-</span> o1.<span style=color:#a6e22e>length</span>()));
</span></span><span style=display:flex><span>        thread1.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这段代码直接执行是没有问题的，可以正常结束，但是稍微修改一下，加点延迟，就会有问题了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;a&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;b&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;c&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;d&#34;</span>);
</span></span><span style=display:flex><span>        list.<span style=color:#a6e22e>add</span>(<span style=color:#e6db74>&#34;e&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Thread thread <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> list.<span style=color:#a6e22e>forEach</span>(a <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                Thread.<span style=color:#a6e22e>sleep</span>(50);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(e);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a);
</span></span><span style=display:flex><span>        }));
</span></span><span style=display:flex><span>        thread.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Thread thread1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread(() <span style=color:#f92672>-&gt;</span> list.<span style=color:#a6e22e>sort</span>((o1, o2) <span style=color:#f92672>-&gt;</span> o2.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>-</span> o1.<span style=color:#a6e22e>length</span>()));
</span></span><span style=display:flex><span>        thread1.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//运行异常</span>
</span></span><span style=display:flex><span>Exception in thread <span style=color:#e6db74>&#34;Thread-0&#34;</span> java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>ConcurrentModificationException</span>
</span></span><span style=display:flex><span>	at java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>ArrayList</span>.<span style=color:#a6e22e>forEach</span>(ArrayList.<span style=color:#a6e22e>java</span>:1262)
</span></span><span style=display:flex><span>	at com.<span style=color:#a6e22e>fc</span>.<span style=color:#a6e22e>se</span>.<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>ListTest</span>.<span style=color:#a6e22e>lambda$main$1</span>(ListTest.<span style=color:#a6e22e>java</span>:23)
</span></span><span style=display:flex><span>	at java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Thread</span>.<span style=color:#a6e22e>run</span>(Thread.<span style=color:#a6e22e>java</span>:750)
</span></span></code></pre></div><p>看异常堆栈是<code>java.util.ArrayList#forEach</code>方法, 会校验modCount != expectedModCount，不符合预期就报错</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>forEach</span>(Consumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> E<span style=color:#f92672>&gt;</span> action) {
</span></span><span style=display:flex><span>        Objects.<span style=color:#a6e22e>requireNonNull</span>(action);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> expectedModCount <span style=color:#f92672>=</span> modCount;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> E<span style=color:#f92672>[]</span> elementData <span style=color:#f92672>=</span> (E<span style=color:#f92672>[]</span>) <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>elementData</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>size</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0; modCount <span style=color:#f92672>==</span> expectedModCount <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>&lt;</span> size; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            action.<span style=color:#a6e22e>accept</span>(elementData<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (modCount <span style=color:#f92672>!=</span> expectedModCount) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ConcurrentModificationException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>现在这个场景变成了在2个线程里对同一个list进行遍历和sort操作.</p><p>看下sort操作</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sort</span>(Comparator<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> E<span style=color:#f92672>&gt;</span> c) {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> expectedModCount <span style=color:#f92672>=</span> modCount;
</span></span><span style=display:flex><span>     Arrays.<span style=color:#a6e22e>sort</span>((E<span style=color:#f92672>[]</span>) elementData, 0, size, c);
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>if</span> (modCount <span style=color:#f92672>!=</span> expectedModCount) {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> ConcurrentModificationException();
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     modCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>这2个代码放一起比较一下就可以看出端倪了，sort()会修改modeCount, 但是不会修改expectedModCount。</p><p>再次进行list.foreach()时，由于<code>modCount != expectedModCount</code>，就会抛出<code>ConcurrentModificationException</code>。</p><p>如果不加<code>Thread.sleep(50);</code>，thread会迅速执行完成，相当于2个线程串行执行，所以不会有并发修改问题。</p><p>加了<code>Thread.sleep(50);</code>，2个线程会并发执行，就会抛异常了。</p><h2 id=解决方式>解决方式<a hidden class=anchor aria-hidden=true href=#解决方式>#</a></h2><p>第一种，避免在迭代器里执行add/remove操作，如果需要在遍历的过程中修改集合，记得使用迭代器进行操作</p><p>第二种也可以归类为迭代器和集合的操作，这种首先也需要避免迭代器和遍历一起操作, 另外多线程需要确保线程安全，按实际情况加锁。</p><h2 id=fail-fast>Fail-Fast<a hidden class=anchor aria-hidden=true href=#fail-fast>#</a></h2><p>上面的栗子就是fail-fast的一种场景，不符合预期，直接报错。</p><h3 id=什么是fail-fast>什么是fail-fast<a hidden class=anchor aria-hidden=true href=#什么是fail-fast>#</a></h3><p>首先我们看下维基百科中关于fail-fast的解释：</p><blockquote><p>In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system&rsquo;s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.</p></blockquote><p>大概意思是：在系统设计中，快速失效系统一种可以立即报告任何可能表明故障的情况的系统。</p><p>快速失效系统通常设计用于停止正常操作，而不是试图继续可能存在缺陷的过程。</p><p>这种设计通常会在操作中的多个点检查系统的状态，因此可以及早检测到任何故障。</p><p>快速失败模块的职责是检测错误，然后让系统的下一个最高级别处理错误。</p><p>其实，这是一种理念，说白了就是在做系统设计的时候先考虑异常情况，一旦发生异常，直接停止并上报。</p><h2 id=fail-safe>Fail-Safe<a hidden class=anchor aria-hidden=true href=#fail-safe>#</a></h2><p>与之相对的还有fail-safe，这是一种并发安全机制。</p><p>为了避免触发fail-fast机制，导致异常，我们可以使用Java中提供的一些采用了fail-safe机制的集合类。</p><p>这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>java.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove 。</p><h2 id=参考文章>参考文章<a hidden class=anchor aria-hidden=true href=#参考文章>#</a></h2><p><a href=https://www.hollischuang.com/archives/3542>一不小心就踩坑的fail-fast是个什么鬼?</a></p></div><div class=post-reward><div style=padding:0;margin:0;width:100%;font-size:16px;text-align:center><div id=QR style=opacity:0><div id=wechat style=display:inline-block><a class=fancybox rel=group><img id=wechat_qr src=https://blog.thend03.com/img/wechat-pay.png alt=wechat_pay></a><p>微信</p></div><div id=alipay style=display:inline-block><a class=fancybox rel=group><img id=alipay_qr src=https://blog.thend03.com/img/alipay.png alt=alipay></a><p>支付宝</p></div></div><button id=rewardButton onclick='var qr=document.getElementById("QR");qr.style.opacity==="0"?qr.style.opacity="1":qr.style.opacity="0"'>
<span>🧧 鼓励</span></button></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://blog.thend03.com/posts/automatic-for-xiaobot-nav/><span class=title>« 上一页</span><br><span>实现小报童分销站的自动化</span>
</a><a class=next href=https://blog.thend03.com/posts/how-to-make-a-xiaobot-nav/><span class=title>下一页 »</span><br><span>如何做一个小报童分销导航</span></a></nav></footer></div><style>.comments_details summary::marker{font-size:20px;content:'👉展开评论';color:var(--content)}.comments_details[open] summary::marker{font-size:20px;content:'👇关闭评论';color:var(--content)}</style><div><details class=comments_details open><summary style="cursor:pointer;margin:50px 0 20px;width:130px"><span style=font-size:20px;color:var(--content)>...</span></summary><div id=tcomment></div></details><script src=https://cdn.staticfile.org/twikoo/1.5.8/twikoo.all.min.js></script><script>twikoo.init({envId:"https://twikoo-e1f2-2yfafx14j-thend03s-projects.vercel.app/",el:"#tcomment",lang:"zh-CN",region:null,path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>Copyright
&copy;
2020-2025
<a href=https://blog.thend03.com/ style=color:#939393>站在海边看远方</a>
All Rights Reserved
</span><a href=https://beian.miit.gov.cn/ target=_blank style=color:#939393></a>&nbsp;
<span><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=null" style=display:inline-block;text-decoration:none;height:20px;color:#939393><img src style="float:left;margin:0 5px 0 0">
</a></span><span id=busuanzi_container><span class="fa fa-user"></span> <span id=busuanzi_value_site_uv></span>
<span class="fa fa-eye"></span> <span id=busuanzi_value_site_pv></span></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><span class=topInner><svg class="topSvg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
<span id=read_progress></span>
</span></a><script>document.addEventListener("scroll",function(){const t=document.getElementById("read_progress"),n=document.documentElement.scrollHeight,s=document.documentElement.clientHeight,o=document.documentElement.scrollTop||document.body.scrollTop;t.innerText=((o/(n-s)).toFixed(2)*100).toFixed(0)})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>let mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>200||document.documentElement.scrollTop>200?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{(function(){document.cookie="change-themes="+escape("false")})(),document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.body.addEventListener("copy",function(e){if(window.getSelection().toString()&&window.getSelection().toString().length>50){let t=e.clipboardData||window.clipboardData;if(t){e.preventDefault();let n=window.getSelection().toString(),s=window.getSelection().toString();t.setData("text/html",n),t.setData("text/plain",s)}}})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="复制";function i(){t.innerText="已复制！",setTimeout(()=>{t.innerText="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){let t=e.textContent;navigator.clipboard.writeText(t),i();return}const n=document.createRange();n.selectNodeContents(e);const s=window.getSelection();s.removeAllRanges(),s.addRange(n);try{document.execCommand("copy"),i()}catch{}s.removeRange(n)});let l=e.className.replaceAll("language-",""),n=document.createElement("div"),a=document.createElement("div"),r=document.createElement("div"),c=document.createElement("div"),o=document.createElement("div");o.innerText=l,n.setAttribute("class","mac-tool"),a.setAttribute("class","mac bb1"),r.setAttribute("class","mac bb2"),c.setAttribute("class","mac bb3"),o.setAttribute("class","language-type"),n.appendChild(a),n.appendChild(r),n.appendChild(c),n.appendChild(o),s.classList.contains("highlight")?(s.appendChild(t),s.appendChild(n)):s.parentNode.firstChild==s||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?(e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t),s.appendChild(n)):(e.parentNode.appendChild(t),s.appendChild(n)))})</script></body></html>